<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOOMSEEK - Transformer Inspection Robot Control</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-color: #00d4ff;
      --secondary-color: #ff6b35;
      --danger-color: #ff3838;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --bg-primary: #0a0e1a;
      --bg-secondary: #141824;
      --bg-tertiary: #1e2433;
      --text-primary: #ffffff;
      --text-secondary: #a0a8b8;
      --border-color: #2a3244;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #0f1419 100%);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Header - Transparent Overlay */
    .header {
      background: transparent;
      border-bottom: none;
      padding: 8px 15px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      gap: 15px;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .emergency-stop {
      padding: 6px 14px;
      background: rgba(255, 56, 56, 0.8);
      border: 1px solid rgba(255, 56, 56, 0.6);
      border-radius: 5px;
      color: white;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(255, 56, 56, 0.3);
      backdrop-filter: blur(10px);
    }

    .emergency-stop:hover {
      background: rgba(255, 56, 56, 0.95);
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 56, 56, 0.5);
    }

    .controls-toggle {
      padding: 6px 14px;
      background: rgba(0, 212, 255, 0.8);
      border: 1px solid rgba(0, 212, 255, 0.6);
      border-radius: 5px;
      color: white;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
      backdrop-filter: blur(10px);
    }

    .controls-toggle:hover {
      background: rgba(0, 212, 255, 0.95);
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
    }

    /* Full Background Camera */
    .camera-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: #000;
      z-index: 1;
    }

    .camera-view {
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .camera-view iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .camera-label {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.8);
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .camera-label-separator {
      width: 1px;
      height: 14px;
      background: var(--primary-color);
      opacity: 0.5;
    }

    .doomseek-badge {
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0.8;
    }

    .doomseek-badge-icon {
      width: 14px;
      height: 14px;
      border-radius: 2px;
      overflow: hidden;
    }

    .doomseek-badge-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .doomseek-badge-text {
      font-size: 8px;
      font-weight: 700;
      color: var(--primary-color);
      letter-spacing: 0.5px;
    }

    /* WiFi Indicator */
    .wifi-indicator {
      display: flex;
      align-items: center;
      gap: 3px;
      margin-left: 6px;
      padding-left: 6px;
      border-left: 1px solid rgba(0, 212, 255, 0.3);
    }

    .wifi-icon {
      width: 12px;
      height: 12px;
      color: var(--primary-color);
      transition: color 0.3s;
    }

    .wifi-percentage {
      font-size: 8px;
      font-weight: 700;
      color: var(--primary-color);
      letter-spacing: 0.3px;
      min-width: 22px;
      text-align: right;
    }

    /* WiFi signal strength colors */
    .wifi-indicator.excellent .wifi-icon,
    .wifi-indicator.excellent .wifi-percentage {
      color: var(--success-color);
    }

    .wifi-indicator.good .wifi-icon,
    .wifi-indicator.good .wifi-percentage {
      color: var(--primary-color);
    }

    .wifi-indicator.fair .wifi-icon,
    .wifi-indicator.fair .wifi-percentage {
      color: var(--warning-color);
    }

    .wifi-indicator.poor .wifi-icon,
    .wifi-indicator.poor .wifi-percentage {
      color: var(--danger-color);
    }

    .wifi-indicator.disconnected .wifi-icon,
    .wifi-indicator.disconnected .wifi-percentage {
      color: var(--text-secondary);
      opacity: 0.5;
    }

    /* WiFi arc animations based on signal strength */
    .wifi-indicator.poor .wifi-arc-2,
    .wifi-indicator.poor .wifi-arc-3 {
      opacity: 0.2;
    }

    .wifi-indicator.fair .wifi-arc-3 {
      opacity: 0.3;
    }

    .wifi-indicator.disconnected .wifi-arc {
      opacity: 0.2;
    }

    /* IMU Calibrate Button */
    .imu-calibrate-btn {
      position: absolute;
      top: 45px;
      left: 12px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      z-index: 10;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .imu-calibrate-btn:hover {
      background: rgba(0, 212, 255, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
    }

    .imu-calibrate-btn:active {
      transform: translateY(0);
    }

    .imu-calibrate-btn.calibrating {
      background: rgba(255, 193, 7, 0.2);
      border-color: #ffc107;
      color: #ffc107;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .recording-indicator {
      position: absolute;
      top: 12px;
      right: 12px;
      display: none;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      background: rgba(255, 0, 0, 0.9);
      border-radius: 15px;
      font-size: 10px;
      font-weight: 600;
      z-index: 10;
    }

    .recording-indicator.active {
      display: flex;
    }

    .rec-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: white;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Small Camera - Bottom Left Overlay (Resizable) */
    .secondary-camera-overlay {
      position: fixed;
      bottom: 15px;
      left: 15px;
      width: 280px;
      height: 180px;
      min-width: 180px;
      min-height: 110px;
      max-width: 500px;
      max-height: 350px;
      background: var(--bg-secondary);
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid var(--primary-color);
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
      z-index: 50;
      resize: both;
    }

    .secondary-camera-overlay::after {
      content: '‚ã∞';
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 12px;
      color: var(--primary-color);
      opacity: 0.5;
      pointer-events: none;
      z-index: 1;
    }

    .secondary-camera-overlay .camera-view {
      height: 100%;
    }

    .secondary-camera-overlay .camera-label {
      position: absolute;
      top: 6px;
      left: 6px;
      padding: 3px 8px;
      font-size: 9px;
      display: flex;
      align-items: center;
    }

    .secondary-camera-overlay .recording-indicator {
      top: 6px;
      right: 6px;
      padding: 3px 8px;
      font-size: 9px;
    }

    .swap-btn {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: var(--primary-color);
      border: none;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      font-size: 9px;
      color: var(--bg-primary);
      transition: all 0.3s ease;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.5);
    }

    .swap-btn:hover {
      background: #00b8e6;
      transform: scale(1.05);
    }

    /* Forward Direction Arrow */
    .forward-arrow {
      position: absolute;
      top: 50px;
      left: 12px;
      z-index: 10;
      opacity: 0.8;
      pointer-events: none;
      animation: arrowPulse 2s ease-in-out infinite;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--warning-color);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Forward arrow in main camera view */
    #main-camera-view .forward-arrow {
      top: 50px;
    }

    /* Forward arrow in secondary camera view */
    .secondary-camera-overlay .forward-arrow {
      top: 35px;
    }

    @keyframes arrowPulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .forward-arrow-icon {
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 14px solid var(--warning-color);
      filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.6));
    }

    .forward-arrow-label {
      color: var(--warning-color);
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      white-space: nowrap;
    }

    /* Bottom Right Info Cluster - Horizontal Layout */
    .bottom-right-cluster {
      position: fixed;
      bottom: 15px;
      right: 15px;
      display: flex;
      flex-direction: row;
      gap: 8px;
      z-index: 50;
      align-items: flex-end;
    }

    /* Controller Input - Ultra Compact with System Status - RESIZABLE */
    .controller-compact {
      background: rgba(30, 36, 51, 0.95);
      border: 1px solid var(--secondary-color);
      border-radius: 4px;
      padding: 5px 10px;
      font-size: 7px;
      line-height: 1.1;
      box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
      width: 350px;
      height: 45px;
      max-width: 600px;
      min-width: 200px;
      min-height: 30px;
      max-height: 120px;
      resize: both;
      overflow: hidden;
      position: relative;
    }

    .controller-compact::after {
      content: '‚ã∞';
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 12px;
      color: var(--secondary-color);
      opacity: 0.5;
      pointer-events: none;
      z-index: 1;
    }

    .controller-compact .controller-row {
      white-space: normal;
      margin-bottom: 3px;
      word-break: break-word;
    }

    .controller-compact .controller-label {
      color: var(--secondary-color);
      font-weight: 700;
      font-size: 6px;
      display: inline;
      margin-right: 6px;
    }

    .controller-compact .controller-value {
      color: #e0e0e0;
      font-weight: 600;
      font-size: 6px;
      font-family: 'Courier New', monospace;
      display: inline;
    }

    .controller-compact .system-status-row {
      white-space: normal;
      border-top: 1px solid var(--border-color);
      padding-top: 3px;
      margin-top: 2px;
      word-break: break-word;
    }

    .controller-compact .system-label {
      color: var(--secondary-color);
      font-weight: 700;
      font-size: 6px;
      display: inline;
      margin-right: 6px;
    }

    .controller-compact .system-value {
      color: #e0e0e0;
      font-weight: 600;
      font-size: 6px;
      font-family: 'Courier New', monospace;
      display: inline;
    }

    /* IMU Data - Ultra Compact Box - RESIZABLE */
    .imu-compact {
      background: rgba(30, 36, 51, 0.95);
      border: 1px solid var(--primary-color);
      border-radius: 4px;
      padding: 5px 8px;
      font-size: 7px;
      line-height: 1.1;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
      width: 130px;
      height: 85px;
      min-width: 85px;
      max-width: 250px;
      min-height: 60px;
      max-height: 180px;
      resize: both;
      overflow: hidden;
      position: relative;
    }

    .imu-compact::after {
      content: '‚ã∞';
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 12px;
      color: var(--primary-color);
      opacity: 0.5;
      pointer-events: none;
      z-index: 1;
    }

    .imu-compact .imu-title {
      color: var(--primary-color);
      font-weight: 700;
      font-size: 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 3px;
      text-align: center;
      border-bottom: 1px solid var(--primary-color);
      padding-bottom: 2px;
    }

    .imu-compact .imu-row {
      display: flex;
      justify-content: space-between;
      margin: 1px 0;
      color: #e0e0e0;
    }

    .imu-compact .imu-label {
      color: #8a9ba8;
      font-weight: 600;
      font-size: 6px;
    }

    .imu-compact .imu-value {
      color: var(--success-color);
      font-weight: 600;
      font-size: 6px;
      font-family: 'Courier New', monospace;
    }

    /* Controls Dropdown Menu - More Compact */
    .controls-dropdown {
      position: fixed;
      top: 0;
      right: -340px;
      width: 320px;
      max-height: 100vh;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
      border-left: 2px solid var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      box-shadow: -5px 5px 20px rgba(0, 0, 0, 0.5);
      transition: right 0.3s ease;
      z-index: 90;
      overflow-y: auto;
      padding: 50px 10px 10px 10px;
      border-bottom-left-radius: 8px;
    }

    .controls-dropdown.open {
      right: 0;
    }

    .mission-timer {
      background: var(--bg-tertiary);
      padding: 6px 8px;
      border-radius: 4px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid var(--border-color);
    }

    .timer-label {
      font-size: 9px;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .timer-display {
      font-size: 14px;
      font-weight: 700;
      font-family: 'Courier New', monospace;
      color: var(--primary-color);
    }

    .control-section {
      background: var(--bg-tertiary);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
    }

    .control-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      background: var(--bg-primary);
      padding: 3px;
      border-radius: 4px;
    }

    .tab-btn {
      flex: 1;
      padding: 5px;
      background: transparent;
      border: none;
      border-radius: 3px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 10px;
      font-weight: 500;
    }

    .tab-btn.active {
      background: var(--primary-color);
      color: var(--text-primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }

    .control-btn {
      padding: 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    .control-btn:hover {
      background: var(--primary-color);
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
    }

    .control-btn:active {
      transform: translateY(0);
    }

    .control-icon {
      font-size: 16px;
      margin-bottom: 3px;
    }

    .speed-control {
      margin-top: 8px;
    }

    .speed-slider {
      width: 100%;
      height: 5px;
      border-radius: 3px;
      background: var(--bg-primary);
      outline: none;
      -webkit-appearance: none;
    }

    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
    }

    .speed-display {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 10px;
      color: var(--text-secondary);
    }

    .camera-controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .camera-action-btns {
      display: flex;
      gap: 4px;
    }

    .camera-btn {
      padding: 4px 8px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 9px;
    }

    .camera-btn:hover {
      background: var(--primary-color);
      color: var(--text-primary);
      border-color: var(--primary-color);
    }

    .recording-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 6px;
      margin-bottom: 5px;
      transition: all 0.3s;
    }

    .recording-item:hover {
      border-color: var(--primary-color);
      background: rgba(0, 212, 255, 0.1);
    }

    .recording-name {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 10px;
    }

    .recording-details {
      font-size: 8px;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }

    .recording-actions {
      display: flex;
      gap: 3px;
    }

    .recording-btn {
      padding: 3px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 9px;
      flex: 1;
      text-align: center;
    }

    .recording-btn:hover {
      background: var(--primary-color);
      color: var(--text-primary);
      border-color: var(--primary-color);
    }

    .recording-btn.delete {
      background: var(--danger-color);
      border-color: var(--danger-color);
      color: white;
    }

    .recording-btn.delete:hover {
      background: #ff5555;
    }

    /* Scrollbar Styling */
    .controls-dropdown::-webkit-scrollbar {
      width: 5px;
    }

    .controls-dropdown::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 3px;
    }

    .controls-dropdown::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 3px;
    }

    .controls-dropdown::-webkit-scrollbar-thumb:hover {
      background: #00b8e6;
    }

    /* Download Progress Bar */
    .download-progress-container {
      display: none;
      align-items: center;
      padding: 7px 14px;
      background: rgba(30, 36, 51, 0.95);
      border: 1px solid var(--primary-color);
      border-radius: 5px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
      min-width: 250px;
      max-width: 350px;
      height: 35px;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 150;
      overflow: hidden;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    .download-progress-container.active {
      display: flex;
    }

    .download-progress-bg {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      width: 0%;
      transition: width 0.3s ease;
      opacity: 0.35;
      border-radius: 5px;
    }

    .download-progress-text {
      position: relative;
      z-index: 1;
      color: white;
      font-weight: 600;
      font-size: 11px;
      text-align: center;
      width: 100%;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <!-- Download Progress Bar (positioned at top center) -->
  <div class="download-progress-container" id="download-progress">
    <div class="download-progress-bg" id="download-progress-bg"></div>
    <div class="download-progress-text" id="download-progress-text">Downloading... 0%</div>
  </div>

  <!-- Header -->
  <div class="header">
    <div style="flex: 1;"></div>
    <div class="header-controls">
      <button class="emergency-stop" onclick="emergencyStop()">‚ö† E-STOP</button>
      <button class="controls-toggle" onclick="toggleControls()">‚ò∞ CONTROLS</button>
    </div>
  </div>

  <!-- Full Background Camera -->
  <div class="camera-background">
    <div class="camera-view" id="main-camera-view">
      <iframe src="http://192.168.8.104:8889/webrtc/camB" id="main-iframe"></iframe>
      <div class="camera-label" id="main-cam-label">
        <span>Inspection Camera</span>
        <div class="camera-label-separator"></div>
        <div class="doomseek-badge">
          <div class="doomseek-badge-icon">
            <img src="86fa564b-cb9d-4137-98f3-51caed427677.jfif" alt="DOOMSEEK">
          </div>
          <span class="doomseek-badge-text">DOOMSEEK</span>
        </div>
        <div class="wifi-indicator" id="wifi-indicator">
          <svg class="wifi-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path class="wifi-arc wifi-arc-1" d="M1 10C5.5 5.5 13 3 17 3C21 3 24 4.5 23 9.5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <path class="wifi-arc wifi-arc-2" d="M5 14C7.5 11.5 11 10 14 10C17 10 19 11 19 14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <path class="wifi-arc wifi-arc-3" d="M9 18C10.5 16.5 12 16 13 16C14 16 15 16.5 15 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <circle class="wifi-dot" cx="12" cy="20" r="1.5" fill="currentColor"/>
          </svg>
          <span class="wifi-percentage" id="wifi-percentage">--</span>
        </div>
      </div>
      <div class="recording-indicator" id="main-recording">
        <div class="rec-dot"></div>
        <span>REC</span>
      </div>
    </div>
  </div>

  <!-- Small Secondary Camera Overlay (Bottom Left) -->
  <div class="secondary-camera-overlay">
    <div class="camera-view">
      <iframe src="http://192.168.8.104:8889/webrtc/camA" id="secondary-iframe"></iframe>
    </div>
    <div class="camera-label" id="secondary-cam-label">Driving Camera</div>
    <div class="recording-indicator" id="secondary-recording">
      <div class="rec-dot"></div>
      <span>REC</span>
    </div>
    <div class="forward-arrow">
      <div class="forward-arrow-icon"></div>
      <span class="forward-arrow-label">FORWARD</span>
    </div>
    <button class="swap-btn" onclick="swapCameras()">‚áÑ SWAP</button>
  </div>

  <!-- Bottom Right Info Cluster -->
  <div class="bottom-right-cluster">
    <!-- Controller Input + System Status - Compact Box (LEFT) -->
    <div class="controller-compact">
      <div class="controller-row">
        <span class="controller-label">CONTROLLER:</span>
        <span class="controller-value" id="input-entry">Waiting for inputs...</span>
      </div>
      <div class="system-status-row">
        <span class="system-label">SYSTEM:</span>
        <span class="system-value" id="system-entry">System ready - DOOMSEEK online</span>
      </div>
    </div>

    <!-- IMU Data Compact (RIGHT) -->
    <div class="imu-compact">
      <div class="imu-title">IMU</div>
      <div class="imu-row">
        <span class="imu-label">Pitch:</span>
        <span class="imu-value" id="pitch">0.0¬∞</span>
      </div>
      <div class="imu-row">
        <span class="imu-label">Roll:</span>
        <span class="imu-value" id="roll">0.0¬∞</span>
      </div>
      <div class="imu-row">
        <span class="imu-label">Yaw:</span>
        <span class="imu-value" id="yaw">0.0¬∞</span>
      </div>
      <div class="imu-row">
        <span class="imu-label">Surface:</span>
        <span class="imu-value" id="surface">Wall</span>
      </div>
    </div>
  </div>

  <!-- Controls Dropdown Menu - More Compact -->
  <div class="controls-dropdown" id="controlsDropdown">
    <!-- Mission Timer -->
    <div class="mission-timer">
      <span class="timer-label">Mission Time</span>
      <span class="timer-display" id="timer">00:00:00</span>
    </div>

    <!-- Camera Action Buttons -->
    <div class="camera-controls-header">
      <span style="font-size: 10px; font-weight: 600; color: var(--text-secondary);">Quick Actions</span>
      <div class="camera-action-btns">
        <button class="camera-btn" onclick="startRecording('main')">‚è∫ Record</button>
        <button class="camera-btn" onclick="takeSnapshot('main')">üì∏ Snap</button>
      </div>
    </div>

    <!-- Control Tabs -->
    <div class="control-section">
      <div class="control-tabs">
        <button class="tab-btn active" onclick="showTab('movement')">Movement</button>
        <button class="tab-btn" onclick="showTab('camera')">Camera</button>
        <button class="tab-btn" onclick="showTab('recordings')">Recordings</button>
      </div>

      <!-- Movement Tab -->
      <div id="movement" class="tab-content active">
        <div class="control-grid">
          <div></div>
          <button class="control-btn" onclick="move('forward')">
            <span class="control-icon">‚Üë</span>
            <span>Forward</span>
          </button>
          <div></div>
          <button class="control-btn" onclick="move('left')">
            <span class="control-icon">‚Üê</span>
            <span>Left</span>
          </button>
          <button class="control-btn" onclick="move('stop')">
            <span class="control-icon">‚¨ú</span>
            <span>Stop</span>
          </button>
          <button class="control-btn" onclick="move('right')">
            <span class="control-icon">‚Üí</span>
            <span>Right</span>
          </button>
          <div></div>
          <button class="control-btn" onclick="move('reverse')">
            <span class="control-icon">‚Üì</span>
            <span>Reverse</span>
          </button>
          <div></div>
        </div>
        <div class="speed-control">
          <div class="speed-display">
            <span>Speed Control</span>
            <span id="speed-value">50%</span>
          </div>
          <input type="range" class="speed-slider" id="speed-slider" min="0" max="100" value="50" oninput="updateSpeed(this.value)">
        </div>
      </div>

      <!-- Camera Tab -->
      <div id="camera" class="tab-content">
        <div class="control-grid">
          <button class="control-btn" onclick="zoomCamera('in')">
            <span class="control-icon">üîç+</span>
            <span>Zoom In</span>
          </button>
          <button class="control-btn" onclick="zoomCamera('out')">
            <span class="control-icon">üîç-</span>
            <span>Zoom Out</span>
          </button>
          <button class="control-btn" onclick="rotateCamera(0)">
            <span class="control-icon">‚ü≤</span>
            <span>Reset</span>
          </button>
          <button class="control-btn" onclick="rotateCamera(90)">
            <span class="control-icon">‚Ü∂</span>
            <span>90¬∞ Left</span>
          </button>
          <button class="control-btn" onclick="rotateCamera(270)">
            <span class="control-icon">‚Ü∑</span>
            <span>90¬∞ Right</span>
          </button>
          <button class="control-btn" onclick="rotateCamera(180)">
            <span class="control-icon">‚ü≥</span>
            <span>180¬∞</span>
          </button>
          <button class="control-btn" onclick="toggleNightVision()">
            <span class="control-icon">üëÅ</span>
            <span>Night</span>
          </button>
          <button class="control-btn" onclick="toggleLED()">
            <span class="control-icon">üí°</span>
            <span>LED</span>
          </button>
          <button class="control-btn" onclick="toggleMagnet()">
            <span class="control-icon">üß≤</span>
            <span>Magnet</span>
          </button>
        </div>
      </div>

      <!-- Recordings Tab -->
      <div id="recordings" class="tab-content">
        <div style="display: flex; gap: 4px; margin-bottom: 8px;">
          <button class="control-btn" onclick="refreshRecordings()" style="flex: 1;">
            <span class="control-icon">üîÑ</span>
            <span>Refresh</span>
          </button>
          <button class="control-btn" onclick="cleanupRecordings()" style="flex: 1;">
            <span class="control-icon">üóëÔ∏è</span>
            <span>Cleanup</span>
          </button>
        </div>
        <div id="recordings-list" style="max-height: 200px; overflow-y: auto;">
          <div style="text-align: center; color: var(--text-secondary); padding: 12px; font-size: 10px;">
            Loading recordings...
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Timer functionality
    let startTime = Date.now();
    function updateTimer() {
      const elapsed = Date.now() - startTime;
      const hours = Math.floor(elapsed / 3600000).toString().padStart(2, '0');
      const minutes = Math.floor((elapsed % 3600000) / 60000).toString().padStart(2, '0');
      const seconds = Math.floor((elapsed % 60000) / 1000).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${hours}:${minutes}:${seconds}`;
    }
    setInterval(updateTimer, 1000);

    // Toggle controls dropdown
    function toggleControls() {
      document.getElementById('controlsDropdown').classList.toggle('open');
    }

    // Tab switching
    function showTab(tabName) {
      const tabs = document.querySelectorAll('.tab-content');
      const buttons = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => tab.style.display = 'none');
      buttons.forEach(btn => btn.classList.remove('active'));

      document.getElementById(tabName).style.display = 'block';
      event.target.classList.add('active');

      if (tabName === 'recordings') {
        refreshRecordings();
      }
    }

    // Camera controls
    let recordingState = {};
    let mediaRecorders = {};
    let recordedChunks = {};
    
    function initHiddenVideos() {
      if (!document.getElementById('hidden-video-container')) {
        const container = document.createElement('div');
        container.id = 'hidden-video-container';
        container.style.display = 'none';
        
        const mainVideo = document.createElement('video');
        mainVideo.id = 'hidden-main-video';
        mainVideo.autoplay = true;
        mainVideo.muted = true;
        
        const secondaryVideo = document.createElement('video');
        secondaryVideo.id = 'hidden-secondary-video';
        secondaryVideo.autoplay = true;
        secondaryVideo.muted = true;
        
        container.appendChild(mainVideo);
        container.appendChild(secondaryVideo);
        document.body.appendChild(container);
        
        loadHiddenStream('main');
        loadHiddenStream('secondary');
      }
    }
    
    async function loadHiddenStream(camera) {
      const iframe = document.getElementById(`${camera === 'main' ? 'main' : 'secondary'}-iframe`);
      const video = document.getElementById(`hidden-${camera}-video`);
      
      const streamUrl = iframe.src.replace('/webrtc/', '/stream/');
      
      try {
        if (streamUrl.includes('.m3u8') || window.Hls) {
          const hls = new Hls();
          hls.loadSource(streamUrl);
          hls.attachMedia(video);
        } else {
          video.src = iframe.src;
        }
      } catch (err) {
        console.log(`Could not load hidden stream for ${camera}:`, err);
      }
    }
    
    function startRecording(camera) {
      const indicator = document.getElementById(`${camera}-recording`);
      const isRecording = indicator.classList.contains('active');
      
      if (!isRecording) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        const filename = `DOOM_SEEK_recording_${camera}_${timestamp}.webm`;
        startAutoRecording(camera, filename, indicator);
      } else {
        stopAutoRecording(camera);
      }
    }

    async function startAutoRecording(camera, filename, indicator) {
      try {
        let video = document.getElementById(`hidden-${camera}-video`);
        let stream = null;
        
        if (video && video.captureStream) {
          stream = video.captureStream();
        } else {
          const response = await fetch('http://192.168.8.104:8000/proxy-record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              camera: camera === 'main' ? 'camB' : 'camA',
              action: 'start'
            })
          });
          
          if (response.ok) {
            recordingState[camera] = { filename, proxy: true };
            indicator.classList.add('active');
            updateSystemStatus(`Recording started: ${filename}`);
            return;
          }
          
          throw new Error('Proxy recording failed');
        }
        
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp8'
        });
        
        recordedChunks[camera] = [];
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks[camera].push(event.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks[camera], { type: 'video/webm' });
          downloadBlob(blob, filename);
          
          delete recordedChunks[camera];
          delete recordingState[camera];
          delete mediaRecorders[camera];

          updateSystemStatus(`Recording saved: ${filename}`);
        };
        
        mediaRecorder.start(1000);
        mediaRecorders[camera] = mediaRecorder;
        recordingState[camera] = { filename, proxy: false };
        
        indicator.classList.add('active');
        updateSystemStatus(`Recording started: ${filename}`);
        
      } catch (err) {
        updateSystemStatus(`Using screen capture method`);
        startFallbackRecording(camera, filename, indicator);
      }
    }
    
    async function startFallbackRecording(camera, filename, indicator) {
      try {
        const iframe = document.getElementById(`${camera === 'main' ? 'main' : 'secondary'}-iframe`);
        
        if (document.pictureInPictureEnabled) {
          const video = document.createElement('video');
          video.src = iframe.src;
          video.muted = true;
          await video.requestPictureInPicture();
          
          const stream = video.captureStream();
          const mediaRecorder = new MediaRecorder(stream);
          
          recordedChunks[camera] = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks[camera].push(e.data);
          };
          
          mediaRecorder.onstop = () => {
            document.exitPictureInPicture();
            const blob = new Blob(recordedChunks[camera], { type: 'video/webm' });
            downloadBlob(blob, filename);
            delete recordedChunks[camera];
            delete mediaRecorders[camera];
          };
          
          mediaRecorder.start(1000);
          mediaRecorders[camera] = mediaRecorder;
          indicator.classList.add('active');
          updateSystemStatus(`Recording via PiP: ${filename}`);
        }
      } catch (err) {
        updateSystemStatus(`Use Windows Game Bar (Win+G) to record`);
      }
    }
    
    async function stopAutoRecording(camera) {
      const indicator = document.getElementById(`${camera}-recording`);
      
      if (recordingState[camera]?.proxy) {
        const response = await fetch('http://192.168.8.103:8000/proxy-record', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            camera: camera === 'main' ? 'camB' : 'camA',
            action: 'stop'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.url) {
            window.open(data.url, '_blank');
          }
        }
      } else if (mediaRecorders[camera]) {
        mediaRecorders[camera].stop();
      }
      
      indicator.classList.remove('active');
      updateSystemStatus(`Recording stopped`);
    }

    async function takeSnapshot(camera) {
      try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        const filename = `DOOM_SEEK_snapshot_${camera}_${timestamp}.png`;
        
        let video = document.getElementById(`hidden-${camera}-video`);
        
        if (!video || !video.videoWidth) {
          const response = await fetch('http://192.168.8.104:8000/proxy-snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              camera: camera === 'main' ? 'camB' : 'camA'
            })
          });
          
          if (response.ok) {
            const blob = await response.blob();
            downloadBlob(blob, filename);
            updateSystemStatus(`Snapshot saved: ${filename}`);
            flashCamera(camera);
            return;
          }
        }
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        if (video && video.videoWidth) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          ctx.drawImage(video, 0, 0);
        } else {
          takeManualSnapshot(camera);
          return;
        }
        
        canvas.toBlob((blob) => {
          downloadBlob(blob, filename);
          updateSystemStatus(`Snapshot saved: ${filename}`);
          flashCamera(camera);
        }, 'image/png');
        
      } catch (err) {
        takeManualSnapshot(camera);
      }
    }
    
    function takeManualSnapshot(camera) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 1920;
      canvas.height = 1080;
      
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#00d4ff';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('DOOM_SEEK Camera Snapshot', canvas.width/2, 100);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '24px Arial';
      ctx.fillText(`Camera: ${camera === 'main' ? 'Inspection' : 'Driving'}`, canvas.width/2, 200);
      ctx.fillText(`Time: ${new Date().toLocaleString()}`, canvas.width/2, 250);
      
      ctx.fillStyle = '#ffaa00';
      ctx.fillText('Stream capture unavailable - Using placeholder', canvas.width/2, 350);
      
      const iframe = document.getElementById(`${camera === 'main' ? 'main' : 'secondary'}-iframe`);
      ctx.fillStyle = '#888';
      ctx.font = '16px monospace';
      ctx.fillText(`Stream URL: ${iframe.src}`, canvas.width/2, 450);
      
      canvas.toBlob((blob) => {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        const filename = `DOOM_SEEK_snapshot_${camera}_${timestamp}_placeholder.png`;
        downloadBlob(blob, filename);
        updateSystemStatus(`Placeholder saved. Use Win+Shift+S for actual frame`);
      }, 'image/png');
    }
    
    function flashCamera(camera) {
      const view = document.getElementById(`${camera}-camera-view`);
      view.style.animation = 'flash 0.3s';
      setTimeout(() => view.style.animation = '', 300);
    }
    
    window.addEventListener('load', initHiddenVideos);
    
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function swapCameras() {
      const mainIframe = document.getElementById('main-iframe');
      const secondaryIframe = document.getElementById('secondary-iframe');
      const mainLabel = document.getElementById('main-cam-label');
      const secondaryLabel = document.getElementById('secondary-cam-label');
      
      [mainIframe.src, secondaryIframe.src] = [secondaryIframe.src, mainIframe.src];
      
      // Get the camera names (first span in each label)
      const mainCameraName = mainLabel.querySelector('span') ? mainLabel.querySelector('span').textContent : mainLabel.textContent;
      const secondaryCameraName = secondaryLabel.textContent;
      
      // Update main label with structured content including DOOMSEEK badge
      mainLabel.innerHTML = `
        <span>${secondaryCameraName}</span>
        <div class="camera-label-separator"></div>
        <div class="doomseek-badge">
          <div class="doomseek-badge-icon">
            <img src="86fa564b-cb9d-4137-98f3-51caed427677.jfif" alt="DOOMSEEK">
          </div>
          <span class="doomseek-badge-text">DOOMSEEK</span>
        </div>
      `;
      
      // Update secondary label with simple text
      secondaryLabel.textContent = mainCameraName;

      // Handle forward arrow - should always be on Driving Camera
      const mainView = document.getElementById('main-camera-view');
      const secondaryView = document.querySelector('.secondary-camera-overlay');
      let forwardArrow = document.querySelector('.forward-arrow');
      
      // Check which camera is now the driving camera
      if (secondaryCameraName === 'Driving Camera') {
        // Driving camera is now in main view - move arrow there
        if (forwardArrow) {
          mainView.appendChild(forwardArrow);
        }
      } else {
        // Driving camera is in secondary view - move arrow there
        if (forwardArrow) {
          secondaryView.appendChild(forwardArrow);
        }
      }

      updateSystemStatus('Camera feeds swapped');
    }

    // Movement controls
    let currentSpeed = 50;
    let currentMovement = null;
    let movementInterval = null;

    function move(direction) {
      if (movementInterval) {
        clearInterval(movementInterval);
        movementInterval = null;
      }

      if (currentMovement === direction) {
        stopMovement();
        return;
      }

      currentMovement = direction;
      updateSystemStatus(`Moving ${direction}`);

      sendMovementCommand(direction);

      movementInterval = setInterval(() => {
        sendMovementCommand(direction);
      }, 100);

      setTimeout(() => {
        if (currentMovement === direction) {
          stopMovement();
        }
      }, 5000);
    }

    function sendMovementCommand(direction) {
      let motor1 = 0, motor2 = 0, action = direction;
      const baseSpeed = Math.round((currentSpeed / 100) * 80);

      switch(direction) {
        case 'forward':
          motor1 = motor2 = baseSpeed;
          break;
        case 'reverse':
          motor1 = motor2 = baseSpeed;
          action = 'reverse';
          break;
        case 'left':
          action = 'Turning Left';
          motor1 = motor2 = baseSpeed * 0.7;
          break;
        case 'right':
          action = 'Turning Right';
          motor1 = motor2 = baseSpeed * 0.7;
          break;
        case 'stop':
          motor1 = motor2 = 0;
          action = 'stop';
          break;
      }

      fetch('http://192.168.8.104:8000/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          motor1_speed: motor1,
          motor2_speed: motor2,
          action: action
        })
      }).catch(err => console.error(err));
    }

    function stopMovement() {
      if (movementInterval) {
        clearInterval(movementInterval);
        movementInterval = null;
      }
      currentMovement = null;
      sendMovementCommand('stop');
      updateSystemStatus('Movement stopped');
    }

    function updateSpeed(value) {
      currentSpeed = parseInt(value);
      document.getElementById('speed-value').textContent = `${value}%`;
      updateSystemStatus(`Speed set to ${value}%`);
    }

    // Camera controls
    function zoomCamera(direction) {
      const action = direction === 'in' ? 'Zoom In' : 'Zoom Out';
      updateSystemStatus(`Camera ${action.toLowerCase()}`);

      fetch('http://192.168.8.104:8000/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          motor1_speed: 0,
          motor2_speed: 0,
          action: action
        })
      }).catch(err => console.error(err));
    }

    function rotateCamera(degrees) {
      const iframes = document.querySelectorAll('iframe');
      iframes.forEach(iframe => {
        iframe.style.transform = `rotate(${degrees}deg)`;
      });
      updateSystemStatus(`Camera rotated ${degrees}¬∞`);
    }

    // Tool functions
    function emergencyStop() {
      updateSystemStatus('EMERGENCY STOP ACTIVATED');
      stopMovement();
    }

    function toggleNightVision() {
      updateSystemStatus('Night vision toggled');
    }

    function toggleLED() {
      updateSystemStatus('LED state toggled');

      fetch('http://192.168.8.104:8000/control', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          motor1_speed: 0,
          motor2_speed: 0,
          action: 'Led On'
        })
      }).catch(err => console.error(err));
    }

    function toggleMagnet() {
      updateSystemStatus('Magnet toggled');
    }

    // Recordings management
    async function refreshRecordings() {
      updateSystemStatus('Refreshing recordings list...');
      try {
        const response = await fetch('http://192.168.8.104:8000/recordings');
        const data = await response.json();
        displayRecordings(data.recordings);
        updateSystemStatus(`Found ${data.recordings.length} recordings`);
      } catch (err) {
        console.error('Error fetching recordings:', err);
        updateSystemStatus('Error fetching recordings');
        document.getElementById('recordings-list').innerHTML =
          '<div style="text-align: center; color: var(--danger-color); padding: 12px; font-size: 10px;">Error loading recordings</div>';
      }
    }

    function displayRecordings(recordings) {
      const recordingsList = document.getElementById('recordings-list');

      if (recordings.length === 0) {
        recordingsList.innerHTML =
          '<div style="text-align: center; color: var(--text-secondary); padding: 12px; font-size: 10px;">No recordings found</div>';
        return;
      }

      recordingsList.innerHTML = recordings.map(recording => `
        <div class="recording-item">
          <div class="recording-name">${recording.filename}</div>
          <div class="recording-details">
            ${recording.size_mb} MB ‚Ä¢ ${new Date(recording.modified).toLocaleString()}
          </div>
          <div class="recording-actions">
            <button class="recording-btn" onclick="parallelDownloadRecording('${recording.path}')">
              üì• Download
            </button>
            <button class="recording-btn delete" onclick="deleteRecording('${recording.path}')">
              üóëÔ∏è Delete
            </button>
          </div>
        </div>
      `).join('');
    }

    // Optimized download function with faster streaming and progress bar
    async function downloadRecording(path) {
      try {
        const filename = path.split('/').pop() || 'recording.bin';
        updateSystemStatus(`Downloading ${filename}...`);

        // Show progress bar
        showDownloadProgress(filename);

        const startTime = performance.now();
        const response = await fetch(`http://192.168.8.104:8000/recordings/download/${encodeURIComponent(path)}`);

        if (!response.ok) {
          throw new Error('Download failed');
        }

        const contentLength = response.headers.get('Content-Length');
        const total = contentLength ? parseInt(contentLength, 10) : 0;

        // Optimized download with larger buffer and speed tracking
        if (total > 0 && response.body) {
          const reader = response.body.getReader();
          const chunks = [];
          let received = 0;
          let lastUpdateTime = startTime;
          let lastReceived = 0;

          // Use larger buffer for better performance
          const bufferSize = 1024 * 1024; // 1MB buffer

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            chunks.push(value);
            received += value.length;

            // Update progress with throttling to avoid excessive updates
            const now = performance.now();
            if (now - lastUpdateTime > 100) { // Update every 100ms
              const percentage = Math.round((received / total) * 100);

              // Calculate download speed
              const timeDiff = (now - lastUpdateTime) / 1000; // seconds
              const bytesDiff = received - lastReceived;
              const speed = bytesDiff / timeDiff; // bytes per second
              const speedMB = (speed / (1024 * 1024)).toFixed(2);

              updateDownloadProgressWithSpeed(percentage, speedMB);
              lastUpdateTime = now;
              lastReceived = received;
            }
          }

          // Final update
          updateDownloadProgress(100);

          // Create blob more efficiently
          const blob = new Blob(chunks, { type: 'application/octet-stream' });

          // Calculate final stats
          const totalTime = (performance.now() - startTime) / 1000;
          const avgSpeed = ((total / (1024 * 1024)) / totalTime).toFixed(2);
          console.log(`Download completed: ${(total / (1024 * 1024)).toFixed(2)}MB in ${totalTime.toFixed(2)}s (${avgSpeed}MB/s)`);

          // Trigger download
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Clean up immediately
          setTimeout(() => URL.revokeObjectURL(url), 100);
        } else {
          // No content length, use optimized blob download
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        hideDownloadProgress();
        updateSystemStatus(`Downloaded ${filename}`);
      } catch (err) {
        console.error('Download error:', err);
        hideDownloadProgress();
        updateSystemStatus(`Error downloading: ${err.message}`);
      }
    }

    // New function to update progress with speed information
    function updateDownloadProgressWithSpeed(percentage, speedMB) {
      const bg = document.getElementById('download-progress-bg');
      const text = document.getElementById('download-progress-text');
      if (bg && text) {
        bg.style.width = `${percentage}%`;
        text.textContent = `üì• ${percentage}% ‚Ä¢ ${speedMB}MB/s`;
      }
    }

    // Ultra-fast parallel download function using range requests
    async function parallelDownloadRecording(path) {
      try {
        const filename = path.split('/').pop() || 'recording.bin';
        updateSystemStatus(`Fast downloading ${filename}...`);
        showDownloadProgress(filename);

        const startTime = performance.now();

        // First, get file size using HEAD request
        const headResponse = await fetch(`http://192.168.8.104:8000/recordings/fast-download/${encodeURIComponent(path)}`, {
          method: 'HEAD'
        });

        if (!headResponse.ok) {
          throw new Error('Failed to get file info');
        }

        const fileSize = parseInt(headResponse.headers.get('Content-Length') || '0');

        if (fileSize === 0) {
          // Fallback to regular download for unknown size
          return downloadRecording(path);
        }

        // Calculate optimal chunk size and number of parallel connections
        const minChunkSize = 1024 * 1024; // 1MB minimum chunk
        const maxConnections = 6; // Optimal for most browsers/servers
        const chunkSize = Math.max(minChunkSize, Math.ceil(fileSize / maxConnections));
        const numChunks = Math.ceil(fileSize / chunkSize);

        // Create download promises for all chunks
        const downloadPromises = [];
        const chunks = new Array(numChunks);
        let totalDownloaded = 0;

        for (let i = 0; i < numChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize - 1, fileSize - 1);

          downloadPromises.push(
            fetch(`http://192.168.8.104:8000/recordings/fast-download/${encodeURIComponent(path)}`, {
              headers: {
                'Range': `bytes=${start}-${end}`
              }
            }).then(async response => {
              if (!response.ok) {
                throw new Error(`Failed to download chunk ${i}`);
              }

              const reader = response.body.getReader();
              const chunkData = [];
              let chunkReceived = 0;

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                chunkData.push(value);
                chunkReceived += value.length;
                totalDownloaded += value.length;

                // Update progress
                const percentage = Math.round((totalDownloaded / fileSize) * 100);
                const elapsed = (performance.now() - startTime) / 1000;
                const speed = ((totalDownloaded / (1024 * 1024)) / elapsed).toFixed(2);

                updateDownloadProgressWithSpeed(percentage, speed);
              }

              // Store chunk in correct position
              chunks[i] = new Blob(chunkData);
              return true;
            })
          );
        }

        // Wait for all chunks to download
        await Promise.all(downloadPromises);

        // Combine all chunks into final blob
        const finalBlob = new Blob(chunks, { type: 'application/octet-stream' });

        // Calculate and log statistics
        const totalTime = (performance.now() - startTime) / 1000;
        const avgSpeed = ((fileSize / (1024 * 1024)) / totalTime).toFixed(2);
        console.log(`Parallel download completed: ${(fileSize / (1024 * 1024)).toFixed(2)}MB in ${totalTime.toFixed(2)}s (${avgSpeed}MB/s) using ${numChunks} parallel connections`);

        // Trigger download
        const url = URL.createObjectURL(finalBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Clean up
        setTimeout(() => URL.revokeObjectURL(url), 100);

        hideDownloadProgress();
        updateSystemStatus(`Fast download complete: ${filename}`);
      } catch (err) {
        console.error('Parallel download error:', err);
        console.log('Falling back to regular download...');
        // Fallback to regular download on error
        return downloadRecording(path);
      }
    }

    function showDownloadProgress(filename) {
      const container = document.getElementById('download-progress');
      const text = document.getElementById('download-progress-text');
      const bg = document.getElementById('download-progress-bg');
      if (container && text && bg) {
        bg.style.width = '0%';
        bg.style.background = 'linear-gradient(90deg, var(--primary-color), var(--secondary-color))';
        text.textContent = 'üì• 0%';
        container.classList.add('active');
      }
    }

    function updateDownloadProgress(percentage) {
      const bg = document.getElementById('download-progress-bg');
      const text = document.getElementById('download-progress-text');
      if (bg && text) {
        bg.style.width = `${percentage}%`;
        text.textContent = `üì• ${percentage}%`;
      }
    }

    function hideDownloadProgress() {
      const container = document.getElementById('download-progress');
      const text = document.getElementById('download-progress-text');
      const bg = document.getElementById('download-progress-bg');
      if (container && text && bg) {
        // Show completion with success color
        bg.style.width = '100%';
        bg.style.background = 'var(--success-color)';
        text.textContent = '‚úì Complete';
        
        setTimeout(() => {
          container.classList.remove('active');
        }, 1500); // Keep visible for 1.5 seconds after completion
      }
    }

    async function deleteRecording(path) {
      if (!confirm(`Are you sure you want to delete ${path}?`)) {
        return;
      }

      try {
        updateSystemStatus(`Deleting ${path}...`);
        const response = await fetch(`http://192.168.8.104:8000/recordings/${path}`, {
          method: 'DELETE'
        });

        if (!response.ok) {
          throw new Error('Delete failed');
        }

        updateSystemStatus(`Deleted ${path}`);
        refreshRecordings();
      } catch (err) {
        console.error('Delete error:', err);
        updateSystemStatus(`Error deleting ${path}`);
      }
    }

    async function cleanupRecordings() {
      if (!confirm('This will delete all recordings older than 7 days. Continue?')) {
        return;
      }

      try {
        updateSystemStatus('Cleaning up old recordings...');
        const response = await fetch('http://192.168.8.104:8000/recordings/cleanup');
        const data = await response.json();

        updateSystemStatus(`Cleanup completed: ${data.deleted} files deleted`);
        refreshRecordings();
      } catch (err) {
        console.error('Cleanup error:', err);
        updateSystemStatus('Error during cleanup');
      }
    }

    // System status logging
    function updateSystemStatus(message) {
      const time = new Date().toTimeString().split(' ')[0];
      const content = `[${time}] ${message}`;
      document.getElementById('system-entry').textContent = content;
    }

    // Fetch IMU data
    async function fetchIMUData() {
      try {
        const response = await fetch('http://192.168.8.104:8000/imu');
        const data = await response.json();

        if (data && data.timestamp) {
          // Calculate pitch and roll from accelerometer data
          let pitch = 0, roll = 0, yaw = 0;

          if (data.accel && data.accel.length >= 3) {
            const [ax, ay, az] = data.accel;
            pitch = Math.atan2(ay, Math.sqrt(ax * ax + az * az)) * (180 / Math.PI);
            roll = Math.atan2(-ax, az) * (180 / Math.PI);
          }

          // Use facing direction as yaw indicator (compass heading)
          const directions = {
            "North": 0, "NE": 45, "East": 90, "SE": 135,
            "South": 180, "SW": 225, "West": 270, "NW": 315
          };
          yaw = directions[data.facing] || 0;

          // Update display
          document.getElementById('pitch').textContent = `${pitch.toFixed(1)}¬∞`;
          document.getElementById('roll').textContent = `${roll.toFixed(1)}¬∞`;
          document.getElementById('yaw').textContent = `${yaw.toFixed(1)}¬∞`;
          document.getElementById('surface').textContent = `${data.surface || 'Unknown'} (${data.facing || 'N/A'})`;
        } else {
          // No data received - show waiting state
          document.getElementById('pitch').textContent = 'Waiting...';
          document.getElementById('roll').textContent = 'Waiting...';
          document.getElementById('yaw').textContent = 'Waiting...';
          document.getElementById('surface').textContent = 'No IMU Data';
        }
      } catch (err) {
        console.error('IMU fetch error:', err);
        // Show error state
        document.getElementById('surface').textContent = 'IMU Error';
      }
    }

    // Fetch controller input data
    async function fetchControllerData() {
      try {
        const response = await fetch('http://192.168.8.104:8000/input');
        const data = await response.json();
        if (data && (data.action || data.timestamp)) {
          const timestamp = data.timestamp || new Date().toLocaleTimeString();
          const action = data.action || 'idle';
          const m1 = data.motor1_speed || 0;
          const m2 = data.motor2_speed || 0;
          const content = `[${timestamp}] ${action} | M1: ${m1} | M2: ${m2}`;
          document.getElementById('input-entry').textContent = content;
        }
      } catch (err) {
        console.error('Controller fetch error:', err);
      }
    }

    // WiFi Signal Strength Update
    async function updateWiFiSignal() {
      try {
        const response = await fetch('http://192.168.8.104:8000/wifi');
        const data = await response.json();

        const wifiIndicator = document.getElementById('wifi-indicator');
        const wifiPercentage = document.getElementById('wifi-percentage');

        if (data && data.connected) {
          const strength = data.signal_strength || 0;
          wifiPercentage.textContent = strength + '%';

          // Remove all quality classes
          wifiIndicator.classList.remove('excellent', 'good', 'fair', 'poor', 'disconnected');

          // Add appropriate quality class based on signal strength
          if (strength >= 80) {
            wifiIndicator.classList.add('excellent');
          } else if (strength >= 60) {
            wifiIndicator.classList.add('good');
          } else if (strength >= 40) {
            wifiIndicator.classList.add('fair');
          } else {
            wifiIndicator.classList.add('poor');
          }
        } else {
          wifiPercentage.textContent = '--';
          wifiIndicator.classList.remove('excellent', 'good', 'fair', 'poor');
          wifiIndicator.classList.add('disconnected');
        }
      } catch (err) {
        console.error('WiFi fetch error:', err);
        const wifiIndicator = document.getElementById('wifi-indicator');
        const wifiPercentage = document.getElementById('wifi-percentage');
        wifiPercentage.textContent = '--';
        wifiIndicator.classList.remove('excellent', 'good', 'fair', 'poor');
        wifiIndicator.classList.add('disconnected');
      }
    }

    // Start fetching data immediately
    fetchIMUData();
    fetchControllerData();
    updateWiFiSignal();

    // Update data periodically with error recovery
    let imuUpdateInterval = setInterval(() => {
      fetchIMUData();
      fetchControllerData();
    }, 200);  // 5Hz update rate

    // Update WiFi signal less frequently (every 2 seconds)
    setInterval(updateWiFiSignal, 2000);

    // Restart polling if connection is lost
    window.addEventListener('online', () => {
      clearInterval(imuUpdateInterval);
      imuUpdateInterval = setInterval(() => {
        fetchIMUData();
        fetchControllerData();
      }, 200);
    });

    // Keyboard controls
    let keyPressed = {};

    document.addEventListener('keydown', (e) => {
      if (keyPressed[e.key]) return;
      keyPressed[e.key] = true;

      switch(e.key.toLowerCase()) {
        case 'arrowup':
        case 'w':
          move('forward');
          break;
        case 'arrowdown':
        case 's':
          move('reverse');
          break;
        case 'arrowleft':
        case 'a':
          move('left');
          break
        case 'arrowright':
        case 'd':
          move('right');
          break;
        case ' ':
          e.preventDefault();
          stopMovement();
          break;
        case 'q':
          zoomCamera('in');
          break;
        case 'e':
          zoomCamera('out');
          break;
        case 'f':
          toggleLED();
          break;
        case 'c':
          takeSnapshot('main');
          break;
        case 'x':
          swapCameras();
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      keyPressed[e.key] = false;
    });

    // Initialize
    updateSystemStatus('System ready - DOOMSEEK online');

    // Auto-scale text in resizable boxes
    function autoScaleText() {
      const controllerBox = document.querySelector('.controller-compact');
      const imuBox = document.querySelector('.imu-compact');

      // Scale controller box text
      if (controllerBox) {
        const width = controllerBox.offsetWidth;
        const baseFontSize = Math.max(5, Math.min(12, width / 40)); // Scale between 5px and 12px
        
        const labels = controllerBox.querySelectorAll('.controller-label, .system-label');
        const values = controllerBox.querySelectorAll('.controller-value, .system-value');
        
        labels.forEach(label => {
          label.style.fontSize = `${baseFontSize}px`;
        });
        values.forEach(value => {
          value.style.fontSize = `${baseFontSize}px`;
        });
      }

      // Scale IMU box text
      if (imuBox) {
        const width = imuBox.offsetWidth;
        const baseFontSize = Math.max(5, Math.min(10, width / 12)); // Scale between 5px and 10px
        
        const title = imuBox.querySelector('.imu-title');
        const labels = imuBox.querySelectorAll('.imu-label');
        const values = imuBox.querySelectorAll('.imu-value');
        
        if (title) {
          title.style.fontSize = `${baseFontSize}px`;
        }
        labels.forEach(label => {
          label.style.fontSize = `${baseFontSize}px`;
        });
        values.forEach(value => {
          value.style.fontSize = `${baseFontSize}px`;
        });
      }
    }

    // Use ResizeObserver to detect size changes
    if (typeof ResizeObserver !== 'undefined') {
      const controllerBox = document.querySelector('.controller-compact');
      const imuBox = document.querySelector('.imu-compact');

      const resizeObserver = new ResizeObserver(entries => {
        autoScaleText();
      });

      if (controllerBox) resizeObserver.observe(controllerBox);
      if (imuBox) resizeObserver.observe(imuBox);
    }

    // Initial scaling
    autoScaleText();
  </script>
</body>
</html>
